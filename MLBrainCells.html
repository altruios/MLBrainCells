
<html>
<body>
<canvas width="320" height="240" id="canvas" class="canvas"></canvas>
<style>
	body{
		max-height: 100vh;
		display:grid;
		grid-template-areas:
		"canvas cellArray";
		grid-template-columns:1fr 1fr; 
		overflow: none;
	}
	.canvas{
		grid-area:canvas;
	}
	.cellArray{
		grid-area: cellArray;
		display:flex; 
		flex-flow: column wrap;
		overflow-y: scroll;
		max-height: 100vh;
	}
	.cell{
		display: grid;
		grid-template-areas: 
		"id numbers"
		"activations weights";
		border:solid;
		width: 550px;
		height:15vh;
	}
	.id{
		grid-area:id;
	}
	.numbers{
		grid-area:numbers;
	}
	.activations{
		grid-area:activations;
		display:flex;
		flex-direction: column;
		overflow-y: none;
		flex-wrap: nowrap;
	}
	.weights{
		grid-area:weights;
		display:flex;
		flex-direction: column;
		overflow-y: none;
		flex-wrap: none;
	}
</style>
<script>

const consoleStyling = 'font-weight: bold; font-size: 50px;color: red; text-shadow: 3px 3px 0 rgb(217,31,38) , 6px 6px 0 rgb(226,91,14) , 9px 9px 0 rgb(245,221,8) , 10px 10px 0 rgb(5,148,68) , 12px 12px 0 rgb(2,135,206) , 13px 13px 0 rgb(4,77,145) , 14px 14px 0 rgb(42,21,113)';
const canvas = document.querySelector('canvas');
const body = document.querySelector('body');
const cellArrayDiv= document.createElement('div');
cellArrayDiv.setAttribute('class',"cellArray");
body.appendChild(cellArrayDiv);
const ctx = canvas.getContext('2d');
const width = canvas.width = window.innerWidth/2	;
const height = canvas.height = window.innerHeight;
const uniuqeKey=makeID();
const colorR = colorRotate();
ctx.fillStyle = 'rgb(250, 250, 250)';
ctx.fillRect(0, 0, width, height);
function createBrain(cellColumnCount, cellRowCount, options)
	{
	var cellRow = cellRowCount;
	var cellColumn = cellColumnCount;
	const offSetY =  35;	
	const offSetX =   32;
	const scaleValX = width/cellColumnCount - offSetX;
	const scaleValY = height/(cellRowCount)-offSetY;
	const cellMatrix = [];
	for(let i=0; cellColumnCount>=i;i++)
		{
		let cellArray = [];			
		cellMatrix.push(cellArray);
	}
	let brain = 
		{
		cellMatrix:cellMatrix,
		cellCount:cellRowCount*cellColumnCount,
		cellColumns:cellColumnCount,
		cellRows:cellRowCount,

		scaleValX:scaleValX,
		scaleValY:scaleValY,
		offSetX:offSetX,
		offSetY:offSetY,
		displayBrain: function()
			{	
			ctx.fillStyle = "white";
			ctx.fillRect(0, 0, width, height);
			brain.cellMatrix.forEach((cellArray)=>
				{ 
				cellArray.forEach((cell)=>
					{ 
					cell.drawSelf();
					if(cell.answerBool)
						{
						cell.textAnswer();
					}
				console.log("cell targets are");
				console.log(cell.targets);		
					cell.targets.forEach(target=>cell.drawLineToTarget(target, brain.cellMatrix[Math.max(0, cell.generation-1)].indexOf(target)));
				});
			});

		},
		updateForward: function()
			{
			brain.cellMatrix.forEach((cellArray)=>
				{
				cellArray.forEach((cell)=>
					{ 
					cell.calculateSelf(); 
					cell.propagateActivationUpdate();
				});
			});	
		},
		clearView:function()
			{
			ctx.fillStyle = colorR.next();
			ctx.fillRect(0,0,width,height);
		},
		train: function(data)
			{
			console.log(typeof data);
			console.log(typeof data[0].answers[0]);
			console.log("train test");
			// we we take in the training data, it should come in the form of an of an array of object with two properties, inputs, desired answers.
			// we need to look at each answer neuorn - LookBack should be a recursive called function that calles itself on an cell in a previous generation/order
			//	let updateArray = [];
			for (let b=0; b< data.length; b++)// for the length of the training data - I.E. we are going assume we are getting many relativly shortly indexed arrays
				{
				if(data[b].answers.length != data[b].questions.length)
					{console.log("bad data"); return false;}	
				for(let c=0;c<data[b].questions.length;c++)
					{
					brain.attachInputLayer(data[b].questions[c]);
					brain.updateForward();
					let direction = brain.determinDirection(data[b].answers[c]); //return an array of updateObject with determined weights bias value adjustments, which each cell gets updated order should be from generation by column;
					brain.cellMatrix.forEach(cellArray=> cellArray.forEach(cell=> cell.adjust(direction.find(x=> x.ID ===cell.ID)))); 
					brain.updateForward();
					brain.displayBrain();
				}	
			}
			//		updateArray.forEach(x=>brain.cellArray.find(y=>y.ID ===x.ID).adjust(x));
			console.log("all training data done");
			alert("win?");
			console.log(brain.cellMatrix);
			console.log("brain");

		},
		testInput: function(inputActivation)
			{
			let iniColumn = brain.cellMatrix[0];
			let randomIndex = getRandomInt(iniColumn.length);
			
			
			iniColumn[randomIndex].activations[0] = inputActivation;
			iniColumn[randomIndex].weights[0] = inputActivation;
		},
		attachInputLayer: function(a1DArrayOfInputs)
			{
			// here we can attach whatever input we want, conform it to a single array, it also needs to generate weights for the cell generation 0
		},
		determinDirection:function(answer)
			{// answer is the array of values of each answer cell we want as a result
			let arrayOfUpDateObjectsForCell = [];
			for(let e=0; e<answer.length; e++)
				{
				let answerCell = brain.cellMatrix[cellMatrix.length-1][e];
				let returnBucket = [];

				arrayOfUpDateObjectsForCell.push(answerCell.whatIwant(answer[e], returnBucket)); 


			}
	
			let list = Flat(arrayOfUpDateObjectsForCell);
			let realList = Clean(list);
			
			return realList;
		}
	};

	brain.cellMatrix.forEach((cellArray)=>
		{
		let thisGen = cellMatrix.indexOf(cellArray);
		let previousGeneration = cellMatrix.indexOf(cellArray)-1;
		if(thisGen == cellMatrix.length-1)
			{	
			let answerCount = options.answers.length;
			for(let i = 0;i<answerCount;i++)
				{
				let x = 0;	
				x+=brain.scaleValX;
				x*=thisGen;
				x+=brain.offSetX;
				let y = (i*brain.scaleValY)+brain.offSetY;
				let cellPosition = {x:x, y:y};	
				let cell = MakeNewCell(cellMatrix[previousGeneration].map(y=>y.getValue()), createRandomWeights(cellMatrix[previousGeneration].length), getRandom(0,0.001),thisGen,i,cellPosition, brain.cellMatrix);
				cell.answerBool = true;	
				cellArray.push(cell);
			}
			
		}
		else
			{
			for(let i=0; i<brain.cellRows; i++)
				{
				let x = 0;
				x+=brain.scaleValX;
				x*=thisGen;
				x+=brain.offSetX;

				let cellPosition = {x:x, y:(i*brain.scaleValY)+brain.offSetY};	
			
				if(cellMatrix.indexOf(cellArray) == 0)
					{
					let activations = [];
					let act = Math.random(0,1);
					activations.push(act);
					let weights = [];
					let weight = Math.random(-1,1);
					weights.push(weight);
					let bias = Math.random(0.1);
					let cell = MakeNewCell(activations, weights, bias,thisGen,i,cellPosition, brain.cellMatrix);
					cellArray.push(cell);

				}
				else
					{
					let cell = MakeNewCell(cellMatrix[previousGeneration].map(y=>y.getValue()), createRandomWeights(cellMatrix[previousGeneration].length), getRandom(0,0.001),thisGen,i,cellPosition, brain.cellMatrix);
					cellArray.push(cell);
				}

			}
		}
	});
	




	PLog("cell array at the end of the day is:L");
	brain.inputlayer = "";
	return brain;
}

function MakeNewCell(activations, weights, bias, generation, order, position, matrix)
	{
	var	 cell = 
		{
		activations:activations,
		weights:weights,
		bias:bias,
		generation:generation,
		order:order,
		nextGenerationTargetKeys:[],
		lastGenerationTargetKeys:[],
		answerBool: false,
		position:position,
		totalValue: function()
			{
			let result = 0;
			try
				{
				if(cell.activations.length == 0)
					{
					return 0;	
				}
			}
			catch
				{
				cell.activations = [0];
			}
			for(let z=0; z<cell.activations.length; z++)
				{
				result += cell.activations[z]*cell.weights[z];
			}
			result = (result + bias);	
			result = Sigmoid(result);
			return result;
		},
		calculateSelf:function()
			{
			let result = 0;	
			for(let z=0; z<cell.activations.length; z++)
				{
				if(cell.generation > 0)
					{
					result += cell.activations[z]*cell.weights[z];
				}
				else
					{
					result += cell.activations[z];
				}
			}
			result = (result + bias);
			result = Sigmoid(result);
			cell.value = result;
			cell.radius = result*30;
		},
		propagateActivationUpdate:function()
			{
			let lastgenerationVal = matrix.length -1;
			if(lastgenerationVal == cell.generation)
				{
				return true;
			}
			if(cell.answerBool === true){return true}
			let ng = cell.generation+1;

			for(let i=0; i < brain.cellMatrix[ng].length; i++) //for the length of the next generation
				{
				console.log(cell);	
				brain.cellMatrix[ng][i].setActivationWithIndex(cell.getValue(),i);
			}
				
			
		},
		drawSelf: function()
			{
			cell.calculateSelf(); //out 	
	   		ctx.beginPath();
	   		let coloring = Colors(cell.value, 'cell');
	   		let A = Math.floor(convertToRange(cell.value, [0,1], [0,10]));
	   		ctx.fillStyle = coloring;
		    ctx.strokeStyle = "black";
		    ctx.arc(cell.position.x, cell.position.y, cell.getRadius(), 0, 2 * Math.PI, false);
		    let biasVal = Math.floor(convertToRange(cell.bias,[-1,1],[0,10]));
     	 	ctx.lineWidth = 10 - biasVal;
     		ctx.fill();
     		ctx.stroke();
     		ctx.font= "10px arial";
     		ctx.fillStyle = "black";
     		let testWeights = cell.calculateWeights();
			let text = "ID:"+cell.ID;
			let text3 = "B:"+biasVal;
     		ctx.fillText(text, cell.position.x, cell.position.y-10);
     		ctx.fillText(text3, cell.position.x, cell.position.y);
     		let updatedDiv = createDisplayCellDiv(cell);
     	
     		let targetDiv = document.getElementById(cell.ID);
     		if(targetDiv != undefined)
     			{
     			targetDiv.replaceWith(updatedDiv);
     		}

		},
		drawLineToTarget: function(target, index)
			{
			let targetWeight = cell.weights[index];
			let colorWeight = convertToRange(targetWeight, [-1,1],[0,1]);
			let thicknessOfLine = Math.floor(convertToRange(targetWeight, [-1,1], [0,9]));
			let coloringSynapse = Colors(colorWeight, 'synapse');
			ctx.lineWidth = thicknessOfLine;
			ctx.strokeStyle = coloringSynapse;
	   		ctx.beginPath();
			ctx.moveTo(
				cell.position.x-cell.radius, //x
				cell.position.y//y
			);	
			
			if(target){
			ctx.lineTo(target.x+target.radius , target.y);
			ctx.stroke();
			}
		},
		textAnswer:function()
			{
			ctx.fillText("amAnswer", cell.position.x,cell.position.y);		
			let Answer = "I DONT KNOW";	
			let colorText = "black";
			if(cell.value < 0.5)
				{
				Answer = "NO";
				colorText = "white";				
			}
			else if(cell.value >= 0.6)
				{Answer = "YES";}
			ctx.lineWidth = 2;
     		let answerText2 = this.getBias();
     		ctx.fillText(Answer , cell.position.x+320, cell.position.y+600);
     		ctx.fillText( "node:"+cell.ID, cell.position.x+320, cell.position.y+630);
		},
		calculateValue()
			{
			let cv = 0;
			if(cell.getActivations().length != cell.getWeights().length)
				{
				return cv;
			}
			for(let y=0;cell.activations.length; y++)
				{
				cv += cell.activations[y]*cell.weights[y];
			}
			cv+=cell.getBias();
			cv = sigmoid(cv);
			this.value = cv;
			return cv;
		},
		calculateWeights()
			{
			let cw = 0;
			try{	
			for(let u=0;u<cell.weights.length; u++)
				{
				cw+=cell.weights[u];
			}
			return cw;}
			catch(e){
				console.log(e);
				return "not a value";
			}
		},
		calculateActivations: function()
			{
			let ca = 0;	
			for(let t=0;t<cell.activations.length; t++)
				{
				ca+=cell.activations[t];
			}
			return ca;
		},
		setId: function()
			{
			this.ID = uniuqeKey.next().value;
		},
		getId:function()
			{
			return this.ID;
		},
		setActivations: function(input)
			{
			this.activations = input;	
		},
		setActivationWithIndex: function(input, index)
			{
			this.activations[index] = input;
		},
		getActivations:function()
			{
			return this.activations;	
		},
		getBias: function()
			{
			return this.bias;
		},
		getWeights: function()
			{
			return this.weights;
		},
		setWeights: function(value)
			{
			this.weights = value;
		},
		randomizeWeights:function(updateDiv)
			{
			for(let a=0;a<this.weights.length;a++)
				{
				let target = this.targets[a];
				let randomSign = 1;
				if(Math.random() > 0.5)
					{
					randomSign = -1;
				}
				this.weights[a] = Math.random(0,1)*randomSign;	
				this.drawLineToTarget(target,a, this.weights[a]);
			}
			if(updateDiv)
				{
				let updatedDiv = createDisplayCellDiv(cell);
				let tg = document.getElementById(cell.ID);
     			if(tg != undefined)
     			{
     			tg.replaceWith(updatedDiv);
     		}

			}
		},
		adjustWeights:function(index, value)
			{
			this.weights[index] = value;
		},
		getValue:function()
			{
			return this.value;	
		},
		getOrder:function()
			{
			return this.order;	
		},
		setValueOverRide: function(val)
			{
			this.value = val;
			},
		adjustBias:function(num, calcFlag)
			{
			this.bias = num;
			if(calcFlag)
				{
				this.drawSelf();
			}	
		},
		getRadius:function()
			{
			return this.value * 50;
		},
		whatIwant:function(answerValue, returnArray)
			{	


			let desiredWeights = this.weights;
			let desiredBias = this.bias;
			let desiredActivations = this.activations;
			let error = (1/2)*Math.pow(cell.value-answerValue,2);
			//this calls whatIreallyReallyWant eventaully
			let desiredObjectChange = 
				{
				ID:this.ID,
				weights:this.weights,
				bias:0,
				activations:this.activations,
				value:answerValue,
				combine:function(yourCloneFriend)
					{
					if(yourCloneFriend == false)
						{
						return;
					}
					console.log("this is:");
					console.log(this);
					console.log("should be desiredObjectChange");	
					this.bias = (1/2)*(this.bias+yourCloneFriend.bias);	
					let cWeight = yourCloneFriend.weights[Symbol.iterator]();
					let cActivations = yourCloneFriend.activations[Symbol.iterator]();
					this.weights.forEach(x=> (1/2)*(x+cWeight.next().value));
					this.activations.forEach(y=> (1/2)*(y+cActivations.next().value));
					this.recalculateValue();
					return this;
				},
				recalculateValue:function()	
					{

					this.value = Sigmoid(arrayMultiply(this.weights, this.activations)+this.bias);
				}	
			}
	
			for(let k = 0; k< this.weights.length; k++)
				{
				let lastValue = Sigmoid(arrayMultiply(desiredWeights, desiredActivations)+desiredBias);
				let lastError = (1/2)*Math.pow(lastValue-answerValue,2);
				for(let l=0;l<3;l++)
					{
					let currentValue = Sigmoid(arrayMultiply(desiredObjectChange.weights, desiredObjectChange.activations)+desiredObjectChange.bias);
					let currentError = (1/2)*Math.pow(currentValue-answerValue,2);
	
					let positiveRange = false;
					if(desiredWeights[k] < 0){ positiveRange = true;}	
					let nudgedWeightArray = NudgeArray(desiredWeights, k, l, positiveRange);	//returns a copy array to test, with weight adjusted.
					let testWeightChange = Sigmoid(arrayMultiply(nudgedWeightArray,desiredActivations)+desiredBias);
					let testWeightError = (1/nudgedWeightArray.length)*Math.pow(testWeightChange - answerValue, 2);
			
					let testWeightResult = compareSmallnumbers('isSmaller', currentError, testWeightError);
					if(testWeightResult);
						{
						desiredWeights = nudgedWeightArray;
						currentError = testWeightError;
					}
					positiveRange=false;
					if(desiredBias < 0){positiveRange = true;}	
					let nudgedBiasVal = this.nudge(desiredBias,l,positiveRange);
					let testBiasChange = Sigmoid(nudgedBiasVal+desiredWeights[k]*desiredActivations[k]);
					let testBiasError = (1/1)*Math.pow(testBiasChange - answerValue, 2);
					let testBiastResult = ('isSmaller', currentError, testBiasError);
					if(testBiastResult);
						{
						
						desiredBias = nudgedBiasVal;
						currentError = testBiasError;
					}
					positiveRange=!!Math.random(0,1)>5;
			
					let nudgedAcitivationArray = NudgeArray(desiredActivations,k,l,positiveRange);
				
					let testActivationChange = Sigmoid(arrayMultiply(nudgedAcitivationArray,desiredWeights)+desiredBias);
					let testActivationError = (1/nudgedAcitivationArray.length)*Math.pow(testActivationChange - answerValue, 2);
					let testActivationResult = compareSmallnumbers('isSmaller', currentError, testActivationError);
					if(testActivationResult);
						{
						desiredActivations[k] = nudgedAcitivationArray[k];	
					

						currentError = testActivationError;
					}

					//and the end of the loop, update the error to the new value
					let errorResult = compareSmallnumbers('isSmaller',lastError, currentError);
			
					if(errorResult)
						{
						lastError = currentError;
					}

				}
				desiredObjectChange.weights[k] = desiredWeights[k];
				desiredObjectChange.bias = desiredBias;
				desiredObjectChange.activations[k] = desiredActivations[k];
				desiredObjectChange.value = Sigmoid(arrayMultiply(desiredObjectChange.weights, desiredObjectChange.activations)+desiredObjectChange.bias);
			
			}



			let combineObject = returnArray.find(x=>x.ID === desiredObjectChange.ID);
			if(!combineObject)
				{
				returnArray.push(desiredObjectChange);
			}		
			
			//that was this object - simple stuff, now we need to call this function
	
			if(Array.isArray(cell.lastGenerationTargetKeys) && cell.lastGenerationTargetKeys.length)
				{				
				let nextActivation = desiredObjectChange.activations[Symbol.iterator]();
				brain.cellMatrix[cell.generation-1].forEach(x=> x.whatIwant(nextActivation.next().value, returnArray));
				return returnArray;

			}
			else  
				{
				return;		
			}
			

		},



		nudge: function(value, Nudgeindex, isPositive)
			{
	
			if(isPositive)
				{
				value+=(Math.random(0,1)/(Nudgeindex+3));
				Sigmoid(value);
			}
			else
				{	
				value+=(Math.random(-1,1)/(Nudgeindex+3));
				Sigmoid(value);

			}
			return Sigmoid(value);
			
		},
		modulate:function(array, type)
			{
			let bucketArray = [];
			let j=0;
			for(i=0;i<array.length;i++)
				{
				bucketArray.push(array[i]);
				j++;
			}
			let targetArray = this.weights;
			if(type == "activations")
				{
				targetArray = this.activations;
			}

			for(k=j;k<targetArray.length;k++)
				{
				bucketArray.push(targetArray[k]);
			}

			return bucketArray;


		},
		adjust:function(desiredAdjustments)
			{
			if(desiredAdjustments!=undefined)
				{	
				this.weights = desiredAdjustments.weights;
				this.bias = desiredAdjustments.bias;
			}
			else
				{
				console.log(desiredAdjustments + "desiredObjectChange");
			}
		}	
	};
	let value = cell.totalValue(); 
	cell.value = value;
	cell.radius = cell.getRadius();
	cell.targets = [];
	cell.setId();
	if(cell.generation > 0)
		{
		console.log(cell);	
		console.log(matrix);	
		let lastGen = matrix[cell.generation-1];
		for(let r=0;r<lastGen.length;r++)
			{
			let posObject = lastGen[r].position;
			posObject.radius = lastGen[r].radius;
			lastGen[r].nextGenerationTargetKeys.push(cell.ID);
			cell.targets.push(posObject);
			cell.lastGenerationTargetKeys.push(lastGen[r].ID);
		}

	}
	else{}
	return cell;	
}
function CreateTestData(Count, inputSize, outputSize, objectCount)
	{//count is the number of sets
	//size is the input space for each test
	//this returns an array of objects with two 2D arrays attached.
	let dataArray = [];	
	for(let k=0;k<objectCount;k++)
		{
		console.log("making data:");	
		let dataObject=
			{
			questions:[],
			answers:[],
		};	
		for(let i=0;i<Count;i++)
			{
			let questionArray = [];	
			for(let l=0;l<inputSize;l++)
				{	
				let question = Math.random(0,1);
				questionArray.push(question);
			}
			dataObject.questions.push(questionArray);
		}
		for(let j=0; j<Count;j++)
			{
			let answerArray = [];
			for(let m = 0; m < outputSize; m++)	
				{
				let answer = 1;
				if(m > 0)	
					{
					answer = 0;
				}
				answerArray.push(answer);
			}
			dataObject.answers.push(answerArray);
		}
		dataArray.push(dataObject);
	}
	console.log(dataArray);
	return dataArray;
}









//helper functions
function NudgeArray(array ,arrayIndex, Nudgeindex, isPositive)
	{
	let returnArray = [];
	array.forEach(x=>returnArray.push(x));	
	let value = returnArray[arrayIndex];
	
	if(isPositive)
				{
				value+=(Math.random(0,1)/(Nudgeindex+3));
				value = Sigmoid(value);
			}
			else
				{	
				value+=(Math.random(-1,1)/(Nudgeindex+3));
				value = Sigmoid(value);
			}

	returnArray.splice(arrayIndex,1,value);
	return returnArray;
}
function createRandomWeights(number)
	{
	let array = [];
	for(let a=0; a<number;a++)
		{
		let randoNum = Math.random();
		if(Math.random()>0.5)
			{
			randoNum*=(-1);
		}
		array.push(randoNum);
	}	
	return  array;
}
function Clean(array)
	{
	let rArray = [];	
	array.forEach((x)=>
		{
		let search = rArray.find(y=>y.ID ===x.ID);	
		if(search === undefined)
			{
			rArray.push(x);
		}
		else
			{
			rArray[rArray.indexOf(search)].combine(x);
		}
	});
	return rArray;
	
}
function* makeID()
	{
	let itters = 0
	while(true)
		{
		yield itters++;
	}
}
function Sigmoid(number)
	{
	let answer = 1/ (1+ Math.pow ( Math.E, ((-1)*number) ) );
	return answer;
}
function getRandom(min, max) 
	{
  	return Math.random() * (max - min) + min;
}
function Colors(brightness, type)
	{
	let brightVal = convertToRange(brightness, [0,1],[0,250]);	
	let brightType = "LIGHT";
	if(brightVal<150)
		{
		brightType = "DARK";
	}
   	switch(type)
   		{
   		case 'cell':
   			if(brightType=="LIGHT")
   				{
   				color = "white"; 
   			}
   			else
   				{
   				color = "grey";
   			}
   				break;		
   		case 'synapse':
   				if(brightType=="DARK")
   				{
   				color = "rgb(255,"+Math.floor(brightVal/4)+","+Math.floor(brightVal/4)+")"; 
   			}
   			else
   				{
   				color = "rgb("+Math.floor(brightVal/2)+","+Math.floor(brightVal/2)+",255)"; 
   			} 
   		  	break;
   	}
		return color;
}
function convertToRange(value, sR, dR)
	{		
  	if (value < sR[0] || value > sR[1])
  		{
  		console.trace(value);	
  		console.log(value+"val is");
  	  	return NaN; 
  	}
  	let sM = sR[1] - sR[0];
  	let dM = dR[1] - dR[0];
  	let adjValue = value - sR[0];
  	let result = (adjValue * dM / sM) + dR[0];
  	return result;
}
function getRandomInt(max) 
	{
	let result = Math.floor(Math.random() * Math.floor(max)); 	
  	return result;
}
function PLog(logthing)
	{
	console.log("%c "+logthing, consoleStyling);
}
function* colorRotate()
	{
	const color = ['red', 'green', 'blue'];
	let garsvn = 0;	
	while(true)
		{
		garsvn++;
		if(garsvn >= 3 ) garsvn = 0;	
		yield color[garsvn];
	}
}
function arrayMultiply(array1, array2)
	{
	let result = 0;	
	let length = array1.length;
	if(array2.length != length)
		{
		console.error("somethingw went amiss here");	
		return result;
	}	
	for(let a=0; a<length;a++)
		{
		result+= array1[a]*array2[a];
	}
	return result;
}

function compareSmallnumbers(operation, number1, number2)
	{ 
	let compareEpsilon = Number.EPSILON;
  	CalcDiff = Math.abs(number1*100000 - number2*100000);
	let isBigger = CalcDiff > compareEpsilon;
	let isSmaller = CalcDiff<compareEpsilon;
 	 switch(operation)
  		{
   		 case "isBigger":
    		return isBigger;
    	case "isSmaller":
    		return isSmaller;
    	default: 
    		return isSmaller;
    	}
    return false;
}
function Flat(array)
	{
	let holdBucket = [];
	let flatten = function(array)
		{
		for(let i = 0; i<array.length;i++)
			{
			if(Array.isArray(array[i]))
				{
				flatten(array[i]);
			}
			else
				{
				holdBucket.push(array[i]);
			}
		}
	}
	let flatttenedArray = [];
	flatten(array, flatttenedArray);
	return holdBucket;

}

function createDisplayCellDiv(cell)
	{
		let cellDiv =  document.createElement('div');
		cellDiv.setAttribute('id', cell.ID);
		cellDiv.setAttribute('class', 'cell');	
     	let numbersDiv = document.createElement('div');
     	numbersDiv.setAttribute('class', 'numbers');
     	numbersDiv.innerHTML = "value:"+cell.value+"<BR>bias:"+cell.bias;
     	let idDiv = document.createElement('div');
     	idDiv.setAttribute('class', 'id');
     	idDiv.innerHTML = "generation:"+cell.generation+"<BR>order:"+cell.order;
     	let weightsDiv = document.createElement('div');
     	weightsDiv.setAttribute('class', "weights");
     	for(let i = 0; i < cell.weights.length;i++)
     		{
     		let weightDisplay = document.createElement('div');
     		weightDisplay.innerHTML = "weight["+i+"]:"+cell.weights[i];
     		weightsDiv.appendChild(weightDisplay);
     	}
     	let activationsDiv = document.createElement('div');
        activationsDiv.setAttribute('class', "activations");
     	for(let i = 0; i < cell.activations.length;i++)
    	{
    	let actDisplay = document.createElement('div');
   		actDisplay.innerHTML = "activations["+i+"]:"+cell.activations[i];
   		activationsDiv.appendChild(actDisplay);
   	}
   	cellDiv.appendChild(idDiv);
   	cellDiv.appendChild(numbersDiv);
  	cellDiv.appendChild(weightsDiv);
    cellDiv.appendChild(activationsDiv);
   	return cellDiv;
}	
let mode = {
	growRate:2,
	randomSeed: "upcomingIdea", // it will vary the order count according to generation
	answers:[0,1,2], //last array still working on the details - placeholder
	input:[], //defined as [number, {interface}] where interface... magic?
}
let prompt1 = window.prompt("generation count?");
let prompt2 = window.prompt("order count?");
console.log(prompt1)
console.log("that was a prompt");
if(prompt1 == NaN)
	{
	prompt1 == 1;
}
if(prompt2 == NaN)
	{
	prompt2 == 1;
}
let brain = createBrain(prompt1,prompt2, mode);
window.onload = function()
	{	
	brain.displayBrain();
	const trainingData = CreateTestData(2,2,2,2);
	const trainButton = document.createElement('button');
	trainButton.innerHTML = "TRAIN!";
	body.prepend(trainButton);	
	trainButton.addEventListener('click', function()
		{
	//	brain.testInput(0.5);
		brain.train(trainingData);
		brain.updateForward();
		brain.displayBrain();
	});
	var isShift = false;
	window.addEventListener('oncontextmenu', (event)=>
		{
		PLog("middle button pressed: making data");
		console.log('done');
		console.log('data is:');
		console.dir(trainingData);

		return false;
	});
	window.addEventListener('keypress', (event)=>
		{
		PLog(event.key)	
		const keyNumber = event.keyCode;
		const keyName = event.key;
		const isNumber = isFinite(keyName);
			if(isNumber)
				{
				try{
					let targetGen = brain.cellMatrix[keyName];
					console.log(targetGen);
					for(let g=0;g<targetGen.length;g++)
						{
						console.log("adjusting the bias");	
						console.log(targetGen);
						targetGen[g].adjustBias(Math.random(-1,1), true);
					}
				}
				catch(e)
					{w
					console.error(e);
				}
			}
			else
				{
				if(keyNumber > 96 && keyNumber < 122)
					{
					var keyNum = keyNumber - 97;	
					PLog(keyNum+" generation targeted");
					
					if(keyNum == 0)
						{
						console.log("last gen");	
						for(let h=0;h<brain.cellMatrix[0].length;h++)
							{
							brain.cellMatrix[0][h].randomizeWeights(true);
						}
					}
					else
						{
						console.log("not last gen");
						let  targetGenWeights = brain.cellMatrix[keyNum];
						for(let h=0;h<targetGenWeights.length;h++)
							{
							targetGenWeights[h].randomizeWeights(true);
							}
						}
						
					}
			}
		},false);
}
</script>
	<div id="container">
	</div>

	</body>
</html>
