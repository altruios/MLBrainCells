
<html>
<body>
<canvas width="320" height="240" id="canvas" class="canvas"></canvas>
<style>
	body{
		max-height: 100vh;
		display:grid;
		grid-template-areas:
		"canvas cellArray";
		grid-template-columns:1fr 1fr; 
		overflow: none;
	}
	.canvas{
		grid-area:canvas;
	}
	.cellArray{
		grid-area: cellArray;
		display:flex; 
		flex-flow: column wrap;
		overflow-y: scroll;
		max-height: 100vh;
	}
	.cell{
		display: grid;
		grid-template-areas: 
		"id numbers"
		"activations weights";
		border:solid;
		width: 550px;
		height:15vh;
	}
	.id{
		grid-area:id;
	}
	.numbers{
		grid-area:numbers;
	}
	.activations{
		grid-area:activations;
		display:flex;
		flex-direction: column;
		overflow-y: none;
		flex-wrap: nowrap;
	}
	.weights{
		grid-area:weights;
		display:flex;
		flex-direction: column;
		overflow-y: none;
		flex-wrap: none;
	}
</style>
<script>

const consoleStyling = 'font-weight: bold; font-size: 50px;color: red; text-shadow: 3px 3px 0 rgb(217,31,38) , 6px 6px 0 rgb(226,91,14) , 9px 9px 0 rgb(245,221,8) , 10px 10px 0 rgb(5,148,68) , 12px 12px 0 rgb(2,135,206) , 13px 13px 0 rgb(4,77,145) , 14px 14px 0 rgb(42,21,113)';
const canvas = document.querySelector('canvas');
const body = document.querySelector('body');
const cellArrayDiv= document.createElement('div');
cellArrayDiv.setAttribute('class',"cellArray");
body.appendChild(cellArrayDiv);
const ctx = canvas.getContext('2d');
const width = canvas.width = window.innerWidth/2	;
const height = canvas.height = window.innerHeight;
const uniuqeKey=makeID();
const colorR = colorRotate();
ctx.fillStyle = 'rgb(250, 250, 250)';
ctx.fillRect(0, 0, width, height);
function createBrain(cellColumnCount, cellRowCount, options)
	{
	var cellRow = cellRowCount;
	var cellColumn = cellColumnCount;
	const offSetY =  35;	
	const offSetX =   32;
	const scaleValX = width/cellColumnCount - offSetX;
	const scaleValY = height/(cellRowCount)-offSetY;;
	let cellArray = [];		
	let brain = 
		{
		cellCount:cellRowCount*cellColumnCount,
		cellColumns:cellColumnCount,
		cellRows:cellRowCount,
		scaleValX:scaleValX,
		scaleValY:scaleValY,
		offSetX:offSetX,
		offSetY:offSetY,
		displayBrain: function()
			{	
			ctx.fillStyle = "white";
			ctx.fillRect(0, 0, width, height);
			for(let w=0;w<brain.cellColumns; w++)
				{
				for(var y=0;y<brain.cellArray.length;y++)
					{
					if(w > 0)
						{
						for(let v=0;v<(brain.cellArray[y].targets.length);v++)
							{
							let targetCell = brain.cellArray[y].targets[v];
							brain.cellArray[y].drawLineToTarget(targetCell, v);
						}
					}
					if(brain.cellArray[y].answerBool)
						{
						brain.cellArray[y].drawSelf();
						brain.cellArray[y].textAnswer();
					}
					else
						{
						brain.cellArray[y].drawSelf();
					}
				}
			}
		},
		updateForward: function()
			{
			for(let a=0; a<brain.cellArray.length;a++)
				{
				brain.cellArray[a].calculateSelf();	
				brain.cellArray[a].propagateActivationUpdate();
			}	
		},
		clearView:function()
			{
			ctx.fillStyle = colorR.next();
			ctx.fillRect(0,0,width,height);
		},
		train: function(data)
			{
			console.log(typeof data);
			console.log(typeof data[0].answers[0]);
			console.log("train test");
			// we we take in the training data, it should come in the form of an of an array of object with two properties, inputs, desired answers.
			// we need to look at each answer neuorn - LookBack should be a recursive called function that calles itself on an cell in a previous generation/order
			for (let b=0; b< data.length; b++)// for the length of the training data - I.E. we are going assume we are getting many relativly shortly indexed arrays
				{
				if(data[b].answers.length != data[b].questions.length)
					{console.log("bad data"); return false;}	
				for(let c=0;c<data[b].questions.length;c++)
					{
					brain.attachInputLayer(data[b].questions[c]);
					console.log(brain);
					console.log("that was brain");
					brain.updateForward();
					console.log(data[b].answers[c]);
					let direction = brain.determinDirection(data[b].answers[c]); //return an array of updateObject with determined weights bias value adjustments, which each cell gets updated order should be from generation by column;
					for(let d=0;d<direction.length;d++)
						{
						console.log(direction);	
						console.log(direction.ID);
						console.log(brain.cellArray);	
						brain.cellArray.find(x=>x.ID === direction.ID).adjust(direction[d]);
					}
					brain.updateForward();
					brain.displayBrain();
					console.log("one sample done."+c+"moving on to next");
				}	
				console.log("one input data done"+b+"is what we did. YAY!!!!");
			}
			console.log("all training data done");
			alert("win?");
		},
		testInput: function(inputActivation)
			{
			let iniColumn = brain.cellArray.filter(x=>x.generation == 0);
			let randomIndex = getRandomInt(iniColumn.length);
			
			
			iniColumn[randomIndex].activations[0] = inputActivation;
			iniColumn[randomIndex].weights[0] = inputActivation;
	//		brain.cellArray.splice(brain.cellArray.indexOf(brain.cellArray.find(x=>x.ID === iniColumn[randomIndex].ID)),1,iniColumn[randomIndex]);
		},
		attachInputLayer: function(a1DArrayOfInputs)
			{
			// here we can attach whatever input we want, conform it to a single array, it also needs to generate weights for the cell generation 0
		},
		determinDirection:function(answer)
			{// answer is the array of values of each answer cell we want as a result
			let summed = [];
			console.log("here we go!");	

			for(a=0;a<brain.cellArray.length;a++)
				{
				let summedObject = 
					{
					ID:"",
					weights:[],
					bias:[],
				};	
				summed.push(summedObject);	
			}
			console.log("dummy array made;");	
			console.log(answer);
			console.log("that was answer");
			for(let e=0; e<answer.length; e++)
				{
				console.log("in the e loop");	
				let answerCell = brain.cellArray.find(x=>x.order == e && x.answerBool === true);
				console.log("answer cell is:");
				console.dir(answerCell);
				console.dir(answer);

				let arrayOfUpDateObjectsForCell = Flat(answerCell.whatIwant(answer[e], []),); 
				console.log(arrayOfUpDateObjectsForCell);
				console.count("that was teh array for that answer cell, there should be 3 calls of this one!!!!");
				for(let f=0;f<arrayOfUpDateObjectsForCell.length;f++) 
					{
					console.count("counting up the length - it is"+f);	
					summed[f].ID = arrayOfUpDateObjectsForCell[f].ID;
					for (let index = 0; index< arrayOfUpDateObjectsForCell[f].length;index++)
						{
						for(let w=0; w<arrayOfUpDateObjectsForCell[f].weights.length;w++)
							{
							console.count("counting up the weights - it is"+w);		
							summed[f].weights[w] += arrayOfUpDateObjectsForCell[f].weights[w];
						}
					}
					for(let b=0; b<arrayOfUpDateObjectsForCell[f].bias.length;b++)
						{
						console.count("counting up the bias - it is"+w);								
						summed[f].bias[b] += arrayOfUpDateObjectsForCell[f].bias[b];
					}
				}
				for(let s=0;s<summed.length;s++)
					{
					console.count("counting up the sum - it is"+s);								
					for(let sw=0; summed[s].weights.length;sw++)	
						{
						console.count("counting up the summedWeights - it is"+sw);									
						Sigmoid(summed[s].weights[sw]);
					}
					for(let sb=0; sb<summed[s].bias.length;sb++)
						{
						console.count("counting up the bias - it is"+sb);										
						Sigmoid(summed[s].bias[sb]);
					}
				}	
			}
			return summed;
		}
	};


	for(let i=0; i <= cellColumn; i++)
		{
		for(let j=0;j<cellRow; j++)
			{
			let cellPosition= {x:(i*scaleValX)+offSetX, y:(j*scaleValY)+offSetY};
			if(i == 0)
				{
				//the first row - should replace this with a better generator	
				let activations = [];
				let act = Math.random();
				activations.push(act);
				let weights = [];
				let weight = Math.random();
				weights.push(weight);
				var cell = MakeNewCell(activations, weights, Math.random(), i, j, cellPosition, cellArray);
				cell.answerBool = false;
			}
			else if(i==cellColumnCount)
				{
				cellRow=options.answers.length;
				let activations =[];
				let act = i;
				activations.push(act);
				let previousGeneration = i-1;
				let lastCellColumn = cellArray.filter( x=> x.generation == previousGeneration);
				let lastCellColumnLength = lastCellColumn.length;
				cell = MakeNewCell(lastCellColumn.map(x=>x.value), createRandomWeights(lastCellColumnLength), getRandom(0,0.001),  i, j,cellPosition, cellArray);
				cell.answerBool = true;
			}
			else{
				let previousGeneration = i-1;
				let lastCellColumn = cellArray.filter( x=> x.generation == previousGeneration);
				let lastCellColumnLength = lastCellColumn.length;
				cell = MakeNewCell(lastCellColumn.map(x=>x.value), createRandomWeights(lastCellColumnLength), getRandom(0,0.001),  i, j,cellPosition, cellArray);
				cell.answerBool = false;
			}
			cellArray.push(cell);
			let div = createDisplayCellDiv(cell);
			cellArrayDiv.appendChild(div);
		}
	}



	PLog("cell array at the end of the day is:L");
	brain.inputlayer = "";
	brain.cellArray = cellArray;
	console.log(brain.cellArray);
	return brain;
}
function createRandomWeights(number)
	{
	let array = [];
	for(let a=0; a<number;a++)
		{
		let randoNum = Math.random();
		if(Math.random()>0.5)
			{
			randoNum*=(-1);
		}
		array.push(randoNum);
	}	
	return  array;
}
function MakeNewCell(activations, weights, bias, generation, order, position, array)
	{
	var	 cell = 
		{
		activations:activations,
		weights:weights,
		bias:bias,
		generation:generation,
		order:order,
		nextGenerationTargetKeys:[],
		answerBool: false,
		position:position,
		totalValue: function()
			{
			let result = 0;
			try
				{
				if(cell.activations.length == 0)
					{
					return 0;	
				}
			}
			catch
				{
				cell.activations = [0];
			}
			for(let z=0; z<cell.activations.length; z++)
				{
				result += cell.activations[z]*cell.weights[z];
			}
			result = (result + bias);	
			result = Sigmoid(result);
			return result;
		},
		calculateSelf:function()
			{
			let result = 0;	
			for(let z=0; z<cell.activations.length; z++)
				{
				if(cell.generation > 0)
					{
					result += cell.activations[z]*cell.weights[z];
				}
				else
					{
					result += cell.activations[z];
				}
			}
			result = (result + bias);
			result = Sigmoid(result);
			cell.value = result;
			cell.radius = result*30;
		},
		propagateActivationUpdate:function()
			{
			let lastgenerationVal = Math.max(array.generation);
			if(lastgenerationVal == cell.generation)
				{
				return true;
			}
			for(let i=0; i < cell.nextGenerationTargetKeys.length; i++)
				{
				let  nextTarget = cell.nextGenerationTargetKeys[i];
				let correctCellIndex = brain.cellArray[cell.nextGenerationTargetKeys[i]].ID;//will have to fix

				if(correctCellIndex != -1)
					{
					brain.cellArray[correctCellIndex].setActivationWithIndex(cell.getValue(), cell.getOrder());
				}
				else{console.error(correctCellIndex);}
			}
		},
		drawSelf: function()
			{
			cell.calculateSelf(); //out 	
	   		ctx.beginPath();
	   		let coloring = Colors(cell.value, 'cell');
	   		let A = Math.floor(convertToRange(cell.value, [0,1], [0,10]));
	   		ctx.fillStyle = coloring;
		    ctx.strokeStyle = "black";
		    ctx.arc(cell.position.x, cell.position.y, cell.getRadius(), 0, 2 * Math.PI, false);
		    let biasVal = Math.floor(convertToRange(cell.bias,[-1,1],[0,10]));
     	 	ctx.lineWidth = 10 - biasVal;
     		ctx.fill();
     		ctx.stroke();
     		ctx.font= "10px arial";
     		ctx.fillStyle = "black";
     		let testWeights = cell.calculateWeights();
			let text = "A:"+A
			let text3 = "B:"+biasVal;
     		ctx.fillText(text, cell.position.x, cell.position.y+20);
     		ctx.fillText(text3, cell.position.x, cell.position.y);
     		let updatedDiv = createDisplayCellDiv(cell);
     	
     		let targetDiv = document.getElementById(cell.ID);
     		if(targetDiv != undefined)
     			{
     			targetDiv.replaceWith(updatedDiv);
     		}

		},
		drawLineToTarget: function(target, index)
			{
			let targetWeight = cell.weights[index];
			let colorWeight = convertToRange(targetWeight, [-1,1],[0,1]);
			let thicknessOfLine = Math.floor(convertToRange(targetWeight, [-1,1], [0,9]));
			let coloringSynapse = Colors(colorWeight, 'synapse');
			ctx.lineWidth = thicknessOfLine;
			ctx.strokeStyle = coloringSynapse;
	   		ctx.beginPath();
			ctx.moveTo(
				cell.position.x-cell.radius, //x
				cell.position.y//y
			);	
			
			if(target){
			ctx.lineTo(target.x+target.radius , target.y);
			ctx.stroke();
			}
		},
		textAnswer:function()
			{
			ctx.fillText("amAnswer", cell.position.x,cell.position.y);		
			let Answer = "I DONT KNOW";	
			let colorText = "black";
			if(cell.value < 0.5)
				{
				Answer = "NO";
				colorText = "white";				
			}
			else if(cell.value >= 0.6)
				{Answer = "YES";}
			ctx.lineWidth = 2;
     		let answerText2 = this.getBias();
     		ctx.fillText(Answer , cell.position.x+320, cell.position.y+600);
     		ctx.fillText( "node:"+cell.ID, cell.position.x+320, cell.position.y+630);
		},
		calculateValue()
			{
			let cv = 0;
			if(cell.getActivations().length != cell.getWeights().length)
				{
				return cv;
			}
			for(let y=0;cell.activations.length; y++)
				{
				cv += cell.activations[y]*cell.weights[y];
			}
			cv+=cell.getBias();
			cv = sigmoid(cv);
			this.value = cv;
			return cv;
		},
		calculateWeights()
			{
			let cw = 0;
			try{	
			for(let u=0;u<cell.weights.length; u++)
				{
				cw+=cell.weights[u];
			}
			return cw;}
			catch(e){
				console.log(e);
				return "not a value";
			}
		},
		calculateActivations: function()
			{
			let ca = 0;	
			for(let t=0;t<cell.activations.length; t++)
				{
				ca+=cell.activations[t];
			}
			return ca;
		},
		setId: function()
			{
			this.ID = uniuqeKey.next().value;
		},
		getId:function()
			{
			return this.ID;
		},
		setActivations: function(input)
			{
			this.activations = input;	
		},
		setActivationWithIndex: function(input, index)
			{
			this.activations[index] = input;
		},
		getActivations:function()
			{
			return this.activations;	
		},
		getBias: function()
			{
			return this.bias;
		},
		getWeights: function()
			{
			return this.weights;
		},
		setWeights: function(value)
			{
			this.weights = value;
		},
		randomizeWeights:function(updateDiv)
			{
			PLog(this.ID);	
			console.table(this.weights);
			console.log("weights go in up top, down below are changes");
			for(let a=0;a<this.weights.length;a++)
				{
				let target = this.targets[a];
				let randomSign = 1;
				if(Math.random() > 0.5)
					{
					randomSign = -1;
				}
				this.weights[a] = Math.random(0,1)*randomSign;	
				this.drawLineToTarget(target,a, this.weights[a]);
			}
			console.table(this.weights);
			if(updateDiv)
				{
				let updatedDiv = createDisplayCellDiv(cell);
				let tg = document.getElementById(cell.ID);
     			if(tg != undefined)
     			{
     			tg.replaceWith(updatedDiv);
     		}

			}
		},
		adjustWeights:function(index, value)
			{
			this.weights[index] = value;
		},
		getValue:function()
			{
			return this.value;	
		},
		getOrder:function()
			{
			return this.order;	
		},
		setValueOverRide: function(val)
			{
			this.value = val;
			},
		adjustBias:function(num, calcFlag)
			{
			this.bias = num;
			if(calcFlag)
				{
				this.drawSelf();
			}	
		},
		getRadius:function()
			{
			return this.value * 50;
		},
		whatIwant:function(answerValue, returnArray)
			{
			if(answerValue ===undefined)
				{
				console.trace(answerValue);	
				}	
			PLog("want I want called on:"+this.ID);	
			console.log("answer value is:"+answerValue);

			let desiredWeights = this.weights;
			let desiredBias = this.bias;
			let desiredActivations = this.activations;
			let error =(1/2)*Math.pow(cell.value-answerValue,2);
			//this calls whatIreallyReallyWant eventaully
			let desiredObjectChange = 
				{
				ID:this.ID,
				weights:this.weights,
				bias:0,
				activations:this.activations
			}
	
			for(let k = 0; k< this.weights.length; k++)
				{
				let lastValue = Sigmoid(arrayMultiply(desiredWeights, desiredActivations)+desiredBias);
				let lastError = (1/2)*Math.pow(lastValue-answerValue,2);
				for(let l=0;l<20;l++)
					{
					let currentValue = Sigmoid(arrayMultiply(desiredObjectChange.weights, desiredObjectChange.activations)+desiredObjectChange.bias);
					let currentError = (1/2)*Math.pow(currentValue-answerValue,2);
	
					let positiveRange = false;
					if(desiredWeights[k] < 0){ positiveRange = true;}	
					let nudgedWeightArray = this.nudge(desiredWeights[k],k,l,positiveRange, "weights");	//returns a copy array to test, with weight adjusted.
					let testWeightChange = Sigmoid(arrayMultiply(nudgedWeightArray,desiredActivations)+desiredBias);
					let testWeightError = (1/2)*Math.pow(testWeightChange - answerValue, 2);
				
					let testWeightResult = compareSmallnumbers('isSmaller', currentError, testWeightError);
					if(testWeightResult);
						{
						desiredWeights = nudgedWeightArray;
						currentError = testWeightError;
					}
					positiveRange=false;
					if(desiredBias < 0){positiveRange = true;}	
					let nudgedBiasVal = this.nudge(desiredBias,k,l,positiveRange);
					let testBiasChange = Sigmoid(nudgedBiasVal+desiredWeights[k]*desiredActivations[k]);
					let testBiasError = (1/2)*Math.pow(testBiasChange - answerValue, 2);
					let testBiastResult = ('isSmaller', currentError, testBiasError);
					if(testBiastResult);
						{
						
						desiredBias = nudgedBiasVal;
						currentError = testBiasError;
					}
					positiveRange=!!Math.random(0,1)>5;
					let nudgedAcitivationArray = this.nudge(desiredActivations[k],k,l,positiveRange, "activations");
					let testActivationChange = Sigmoid(arrayMultiply(nudgedAcitivationArray,desiredWeights)+desiredBias);
					let testActivationError = (1/2)*Math.pow(testActivationChange - answerValue, 2);
					let testActivationResult = compareSmallnumbers('isSmaller', currentError, testActivationError);
					if(testActivationResult);
						{
						desiredActivations[k] = testActivationChange;	
						lastError = testActivationError;
					}

					//and the end of the loop, update the error to the new value
					if(currentError<lastError)
						{
						lastError = currentError;
					}

				}
				desiredObjectChange.weights[k] = desiredWeights[k];
				desiredObjectChange.bias = desiredBias;
				desiredObjectChange.activations[k] = desiredActivations[k];
				desiredObjectChange.value = Sigmoid(arrayMultiply(desiredObjectChange.weights, desiredObjectChange.activations)+desiredObjectChange.bias);
			}

			//that was this object - simple stuff, now we need to call this function
			if(returnArray.length > 0)
				{
				PLog("this greater than zero, so we must be in a return somewhere");
				console.log(this)	
				console.log("doing some cleanup.");	
				console.log("in a recursion");
				returnArray = Flat(returnArray);	
				let old = returnArray.find(x=>x.ID === desiredObjectChange.ID);
				if(old)
					{
					console.log("is old");		
					old.bias/=desiredObjectChange.bias*2;	
					for(let o=0;o<desiredObjectChange.weights.length;o++)
						{
						old.weights[o]/=desiredObjectChange.weights[o]*2;
                        old.activations[o]/=desiredObjectChange.activations[0]*2;
					}
				}
				else
					{
					console.log("pushing desired object change since it is new to the array");	
					returnArray.push(desiredObjectChange);
				}
			}
			else
				{
				console.log("pushing desired object change since returnArray.length is zero");		
				returnArray.push(desiredObjectChange);
			}
			let lastGen = brain.cellArray.filter(x=>x.generation === this.generation-1);

			let lgl = lastGen.length;
	
			if(cell.order == brain.cellArray.filter(x=>x.generation === cell.generation).length)
				{
				console.log("done with ordered row, returning array into next gen cells array");	
				//done with ordered Row - returning array.	
				returnArray = Flat(returnnArray);	
				return returnArray;
			}
			else if(cell.generation  > 0)	
				{
				console.log("generation is greater than zero so we are starting a return array");	
				//we haven't reached the end yet.
				let returnedArray = [];	
				console.log(lastGen);
				let lg=lastGen[0].generation;
				console.log("for the length of the last generation's generation number:"+lastGen[0].generation);	
				for(let g = lg; g>0;g--)
					{
					console.log("at index [g](generations)"+g);	
					console.log("for the length of the last generation itself:"+lgl);		
					for(let i =0; i < lgl ; i++)
						{
						console.log("at index [i](order)"+i);		
						//this is the array from calling
						PLog("we push into the return array - an array returned by whatIwant on an cell at generation:"+g+" and order"+i);
						returnedArray.push(lastGen.find(x=>x.generation === g).whatIwant(desiredObjectChange.value, returnedArray));

					}

					//we finished a colummn at this point -- we are returning an array up
					returnedArray = Flat(returnedArray);
					return returnedArray; // this seems to be the unintended end to the recursion.

				}
				returnArray = Flat(returnArray);	
				return returnArray; // returned array vs return array... 
			}
			else
				{
				return "no really, WHAT??";
			}
		},



		nudge: function(value ,arrayIndex, Nudgeindex, isPositive, type)
			{
	
			if(isPositive)
				{
				value+=(Math.random(0,1)/(Nudgeindex+1));
				Sigmoid(value);
			}
			else
				{	
				value+=(Math.random(-1,1)/(Nudgeindex+1));
				Sigmoid(value);

			}
			let copyArray = [];
			if(type == "weights")
				{
				copyArray = this.weights;
			}
			else if(type == "activations")
				{
				copyArray = this.activations;	
			}
			else
				{
				return value;
			}
			copyArray.splice(arrayIndex,1,value);
			return copyArray;
		},
		modulate:function(array, type)
			{
			let bucketArray = [];
			let j=0;
			for(i=0;i<array.length;i++)
				{
				bucketArray.push(array[i]);
				j++;
			}
			let targetArray = this.weights;
			if(type == "activations")
				{
				targetArray = this.activations;
			}

			for(k=j;k<targetArray.length;k++)
				{
				bucketArray.push(targetArray[k]);
			}

			return bucketArray;


		},
		adjust:function(desiredAdjustments)
			{
			this.weights = desiredAdjustments.weights;
			this.bias = desiredAdjustments.bias;
		}	
	};
	let value = cell.totalValue(); 
	cell.value = value;
	cell.radius = cell.getRadius();
	cell.targets = [];
	cell.setId();
	if(cell.generation > 0)
		{
		let lastGen = array.filter(x=>x.generation === cell.generation-1);
		for(let r=0;r<lastGen.length;r++)
			{
			let posObject = lastGen[r].position;
			posObject.radius = lastGen[r].radius;
			lastGen[r].nextGenerationTargetKeys.push(cell.ID);
			cell.targets.push(posObject);
		}
	}
	return cell;	
}
function CreateTestData(Count, inputSize, outputSize, objectCount)
	{//count is the number of sets
	//size is the input space for each test
	//this returns an array of objects with two 2D arrays attached.
	let dataArray = [];	
	for(let k=0;k<objectCount;k++)
		{
		console.log("making data:");	
		let dataObject=
			{
			questions:[],
			answers:[],
		};	
		for(let i=0;i<Count;i++)
			{
			let questionArray = [];	
			for(let l=0;l<inputSize;l++)
				{	
				let question = Math.random(0,1);
				questionArray.push(question);
			}
			dataObject.questions.push(questionArray);
		}
		for(let j=0; j<Count;j++)
			{
			let answerArray = [];
			for(let m = 0; m < outputSize; m++)	
				{
				let answer = 0;
				if(Math.random(0,1) > 0.5)	
					{
					answer = 1;
				}
				answerArray.push(answer);
			}
			dataObject.answers.push(answerArray);
		}
		dataArray.push(dataObject);
	}
	console.log(dataArray);
	return dataArray;
}









//helper functions
function* makeID()
	{
	let itters = 0
	while(true)
		{
		yield itters++;
	}
}
function Sigmoid(number)
	{
	let answer = 1/ (1+ Math.pow ( Math.E, ((-1)*number) ) );
	return answer;
}
function getRandom(min, max) 
	{
  	return Math.random() * (max - min) + min;
}
function Colors(brightness, type)
	{
	let brightVal = convertToRange(brightness, [0,1],[0,250]);	
	let brightType = "LIGHT";
	if(brightVal<150)
		{
		brightType = "DARK";
	}
   	switch(type)
   		{
   		case 'cell':
   			if(brightType=="LIGHT")
   				{
   				color = "white"; 
   			}
   			else
   				{
   				color = "grey";
   			}
   				break;		
   		case 'synapse':
   				if(brightType=="DARK")
   				{
   				color = "rgb(255,"+Math.floor(brightVal/4)+","+Math.floor(brightVal/4)+")"; 
   			}
   			else
   				{
   				color = "rgb("+Math.floor(brightVal/2)+","+Math.floor(brightVal/2)+",255)"; 
   			} 
   		  	break;
   	}
		return color;
}
function convertToRange(value, sR, dR)
	{		
  	if (value < sR[0] || value > sR[1])
  		{
  		console.trace(value);	
  		console.log(value+"val is");
  	  	return NaN; 
  	}
  	let sM = sR[1] - sR[0];
  	let dM = dR[1] - dR[0];
  	let adjValue = value - sR[0];
  	let result = (adjValue * dM / sM) + dR[0];
  	return result;
}
function getRandomInt(max) 
	{
	let result = Math.floor(Math.random() * Math.floor(max)); 	
  	return result;
}
function PLog(logthing)
	{
	console.log("%c "+logthing, consoleStyling);
}
function* colorRotate()
	{
	const color = ['red', 'green', 'blue'];
	let garsvn = 0;	
	while(true)
		{
		garsvn++;
		if(garsvn >= 3 ) garsvn = 0;	
		yield color[garsvn];
	}
}
function arrayMultiply(array1, array2)
	{
	let result = 0;	
	let length = array1.length;
	if(array2.length != length)
		{
		console.error("somethingw went amiss here");	
		return result;
	}	
	for(let a=0; a<length;a++)
		{
		result+= array1[a]*array2[a];
	}
	return result;
}

function compareSmallnumbers(operation, number1, number2)
	{ 
	let compareEpsilon = Number.EPSILON;
  	CalcDiff = Math.abs(number1*100000 - number2*100000);
	let isBigger = CalcDiff > compareEpsilon;
	let isSmaller = CalcDiff<compareEpsilon;
 	 switch(operation)
  		{
   		 case "isBigger":
    		return isBigger;
    	case "isSmaller":
    		return isSmaller;
    	default: 
    		return isSmaller;
    	}
    return false;
}
function Flat(array)
	{
	let flatten = function(array, bucket)
		{
		for(let i = 0; i<array.length;i++)
			{
			if(Array.isArray(array[i]))
				{
				flatten(array[i], bucket);
			}
			else
				{
				bucket.push(array[i]);
			}	
		}
	}
	let flatttenedArray = [];
	flatten(array, flatttenedArray);
	return flatttenedArray;

}
function createDisplayCellDiv(cell)
	{
		let cellDiv =  document.createElement('div');
		cellDiv.setAttribute('id', cell.ID);
		cellDiv.setAttribute('class', 'cell');	
     	let numbersDiv = document.createElement('div');
     	numbersDiv.setAttribute('class', 'numbers');
     	numbersDiv.innerHTML = "value:"+cell.value+"<BR>bias:"+cell.bias;
     	let idDiv = document.createElement('div');
     	idDiv.setAttribute('class', 'id');
     	idDiv.innerHTML = "generation:"+cell.generation+"<BR>order:"+cell.order;
     	let weightsDiv = document.createElement('div');
     	weightsDiv.setAttribute('class', "weights");
     	for(let i = 0; i < cell.weights.length;i++)
     		{
     		let weightDisplay = document.createElement('div');
     		weightDisplay.innerHTML = "weight["+i+"]:"+cell.weights[i];
     		weightsDiv.appendChild(weightDisplay);
     	}
     	let activationsDiv = document.createElement('div');
        activationsDiv.setAttribute('class', "activations");
     	for(let i = 0; i < cell.activations.length;i++)
    	{
    	let actDisplay = document.createElement('div');
   		actDisplay.innerHTML = "activations["+i+"]:"+cell.activations[i];
   		activationsDiv.appendChild(actDisplay);
   	}
   	cellDiv.appendChild(idDiv);
   	cellDiv.appendChild(numbersDiv);
  	cellDiv.appendChild(weightsDiv);
    cellDiv.appendChild(activationsDiv);
   	return cellDiv;
}	
let mode = {
	growRate:2,
	randomSeed: "upcomingIdea", // it will vary the order count according to generation
	answers:["NO", "I Don't Know", "Yes"], //last array still working on the details - placeholder
	input:[], //defined as [number, {interface}] where interface... magic?
}
let prompt1 = window.prompt("generation count?");
let prompt2 = window.prompt("order count?");
console.log(prompt1)
console.log("that was a prompt");
if(prompt1 == NaN)
	{
	prompt1 == 1;
}
if(prompt2 == NaN)
	{
	prompt2 == 1;
}
let brain = createBrain(prompt1,prompt2, mode);
window.onload = function()
	{	
	brain.displayBrain();
	const trainingData = CreateTestData(22,200,3,222);
	window.addEventListener('click', function()
		{
	//	brain.testInput(0.5);
		brain.train(trainingData);
		brain.updateForward();
		brain.displayBrain();
	});
	var isShift = false;
	window.addEventListener('oncontextmenu', (event)=>
		{
		PLog("middle button pressed: making data");
		console.log('done');
		console.log('data is:');
		console.dir(trainingData);

		return false;
	});
	window.addEventListener('keypress', (event)=>
		{
		PLog(event.key)	
		const keyNumber = event.keyCode;
		const keyName = event.key;
		const isNumber = isFinite(keyName);
			if(isNumber)
				{
				try{
					let targetGen = brain.cellArray.filter(x=>x.generation == keyName);
					console.log(targetGen);
					for(let g=0;g<targetGen.length;g++)
						{
						console.log("adjusting the bias");	
						console.log(targetGen);
						brain.cellArray.find(x=> x.ID === targetGen[g].ID).adjustBias(Math.random(-1,1), true);
					}
				}
				catch(e)
					{
					console.error(e);
				}
			}
			else
				{
				if(keyNumber > 96 && keyNumber < 122)
					{
					var keyNum = keyNumber - 97;	
					PLog(keyNum+" generation targeted");
					
					if(keyNum == 0)
						{
						console.log("last gen");	
						let  targetGenWeights = brain.cellArray.filter(x=>x.generation === 0);
						for(let h=0;h<targetGenWeights.length;h++)
							{
							targetGenWeights[h].randomizeWeights(true);
						}
					}
					else
						{
							console.log("not last gen");
						let  targetGenWeights = brain.cellArray.filter(x=>x.generation === keyNum);
						for(let h=0;h<targetGenWeights.length;h++)
							{
							targetGenWeights[h].randomizeWeights(true);
							}
						}
						
					}
			}
		},false);
}
</script>
	<div id="container">
	</div>

	</body>
</html>